const std = @import("std");
const http = std.http;
const album_code = "06zWjeOA3MwBHLApKUS3Qs?si=LkxC6rN9QhmXiY67dQ6QYQ";
const SerializedToken = @import("spotify-token").SerializedToken;
const AlbumRequest = @import("album").AutoGenerated;
const TrackSearch = @import("track").TrackSearchResult;
const get_song_names = @import("file-extractor").get_song_names;
const SongMetadata = @import("file-extractor").SongMetadata;
const Playlist = @import("playlist").Playlist;

fn make_sample_request(token: []const u8, alloc: std.mem.Allocator, album_id: []const u8) !std.ArrayList(u8) {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    var local_arena = std.heap.ArenaAllocator.init(gpa.allocator());
    defer local_arena.deinit();
    const url = try std.fmt.allocPrint(local_arena.allocator(), "https://api.spotify.com/v1/albums/{s}", .{album_id});
    var client = http.Client{ .allocator = local_arena.allocator() };
    var buffer = std.ArrayList(u8).init(alloc);
    const bearer = try std.fmt.allocPrint(local_arena.allocator(), "Bearer {s}", .{token});
    const respcode = try client.fetch(http.Client.FetchOptions{
        .headers = .{ .authorization = .{ .override = bearer } },
        .location = .{ .uri = try std.Uri.parse(url) },
        .method = .GET,
        .response_storage = .{ .dynamic = &buffer },
    });
    std.debug.print("Request Status: {}\n", .{respcode.status});

    return buffer;
}

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    var arena = std.heap.ArenaAllocator.init(gpa.allocator());
    defer arena.deinit();
    var tokener = try SerializedToken.init(arena.allocator());
    const token = try tokener.retrieve();
    var playlist = try Playlist.build(arena.allocator(), "11140152173", "pillo");
    try playlist.create();

    std.debug.print("Request made using token : {s}\n", .{token});
    const songs_in_dir = try get_song_names("/home/gonik/Music/Nicotine/Wuzzelbud KK", arena.allocator());

    std.debug.print("Canciones son {d}\n", .{songs_in_dir.items.len});
    var song_results = std.ArrayList(TrackSearch).init(arena.allocator());
    for (songs_in_dir.items) |song| {
        std.debug.print("song_query: {s}\n", .{song});
        const result = try TrackSearch.make_request(
            arena.allocator(),
            &tokener,
            song.song,
            song.album,
            song.artist,
            2,
        );
        try song_results.append(result);
        const track = result.tracks.items[0];
        errdefer std.debug.print("Failing query {s} {s} {s}", .{ song.song, song.album, song.artist });
        std.debug.print("song_result:  {s} {s} {s}\n", .{ track.name, track.artists[0].name, track.album.name });
    }
    try playlist.populate(song_results.items);
    for (playlist.tracks.?) |track| {
        std.debug.print("track in p {any}", .{track});
    }
    try playlist.create();
    try playlist.upload();
    const args = try std.process.argsAlloc(arena.allocator());
    const path = if (args.len >= 2) args[1] else {
        std.debug.print("Provide a spotify album code\n", .{});
        return;
    };

    const api_response = try make_sample_request(
        token,
        arena.allocator(),
        path,
    );
    const resp = api_response.items;
    const laika = try deserialize(resp, arena.allocator());
    std.debug.print("Tracks = {s}\n", .{laika.tracks.href});
    std.debug.print("Artista = {s}\n", .{laika.artists[0].name});
}

fn deserialize(response: []const u8, alloc: std.mem.Allocator) !AlbumRequest {
    const parsed = try std.json.parseFromSlice(AlbumRequest, alloc, response, .{ .ignore_unknown_fields = true });
    return parsed.value;
}
