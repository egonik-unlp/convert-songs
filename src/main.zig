const std = @import("std");
const http = std.http;
const SerializedToken = @import("spotify-token").SerializedToken;
const AlbumRequest = @import("album").AutoGenerated;
const TrackSearch = @import("track").TrackSearchResult;
const get_song_names = @import("file-extractor").get_song_names;
const SongMetadata = @import("file-extractor").SongMetadata;
const Playlist = @import("playlist").Playlist;
const TokenReponse = @import("playlist").TokenResponse;
const httpz = @import("httpz");
const Oauth2Flow = @import("server").Oauth2Flow;
const clap = @import("clap");
const ParseError = error{ ParseNameError, NoPathError };

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer {
        const result = gpa.deinit();
        std.debug.print("De memoria quedamos con {any}\n", .{result});
    }
    var arena = std.heap.ArenaAllocator.init(gpa.allocator());
    defer arena.deinit();

    const params = comptime clap.parseParamsComptime(
        \\-h, --help             Display this help and exit.
        \\-d, --desc <str>       Playlist description.
        \\-n, --name <str>       Playlist name.
        \\-p, --path <str>       Folder path.
        \\
    );
    var diag = clap.Diagnostic{};
    var res = clap.parse(clap.Help, &params, clap.parsers.default, .{
        .diagnostic = &diag,
        .allocator = arena.allocator(),
    }) catch |err| {
        // Report useful error and exit.
        diag.report(std.io.getStdErr().writer(), err) catch {};
        return err;
    };
    defer res.deinit();
    if (res.args.help != 0)
        return clap.help(std.io.getStdErr().writer(), clap.Help, &params, .{});
    const path = pn: {
        if (res.args.path) |path| {
            break :pn path;
        } else {
            std.debug.print("No se proveyo ningun path para explorar.\n", .{});
            try clap.help(std.io.getStdErr().writer(), clap.Help, &params, .{});
            return ParseError.NoPathError;
        }
    };

    const playlist_name = pn: {
        if (res.args.name) |name| {
            break :pn name;
        } else {
            std.debug.print("No se proveyo ningun nombre para la playlist.\n", .{});
            try clap.help(std.io.getStdErr().writer(), clap.Help, &params, .{});
            return ParseError.ParseNameError;
        }
    };

    const playlist_description = pd: {
        if (res.args.desc) |desc| {
            break :pd desc;
        } else {
            break :pd "Creado con convert-songs";
        }
    };

    var tokener = try SerializedToken.init(arena.allocator());
    _ = try tokener.retrieve();
    var flow = try Oauth2Flow.build(8888, arena.allocator());
    var thread = try flow.run();
    defer thread.join();
    defer flow.server.stop();

    const progress = std.Progress.start(.{ .root_name = "Procesando tracks" });
    defer progress.end();

    var songs_in_dir = try get_song_names(path, gpa.allocator(), progress);
    if (songs_in_dir.items.len == 0) {
        std.debug.print("No tracks detected", .{});
        return;
    }
    std.debug.print("Canciones son {d}\n", .{songs_in_dir.items.len});
    var song_results = std.ArrayList(TrackSearch).init(arena.allocator());

    const search_subnode = progress.start("Searching Tracks", songs_in_dir.items.len);
    defer search_subnode.end();
    defer songs_in_dir.deinit();
    var pool: std.Thread.Pool = undefined;
    const cpus = try std.Thread.getCpuCount();
    try pool.init(.{ .allocator = arena.allocator(), .n_jobs = cpus, .track_ids = true });
    var logs = try std.fs.cwd().createFile("logs.log", .{});
    var wg = std.Thread.WaitGroup{};
    var global_state: GlobalState = .{ .lock = .{}, .results = &song_results, .progress = search_subnode, .logs = &logs, .errlock = .{}, .wg = &wg };

    for (songs_in_dir.items, 0..) |song_query, job| {
        try pool.spawn(search_track_threaded, .{ &global_state, arena.allocator(), &tokener, song_query });
        wg.start();
        if (job % 4 == 0) {
            std.Thread.sleep(2_000_000_000);
        }
    }
    wg.wait();
    defer pool.deinit();

    for (songs_in_dir.items) |song| {
        song.deinit();
    }
    defer song_results.deinit();
    std.debug.print("Se procesaron todas las canciones del directorio seleccionado\n", .{});
    // Wait for 0.5s for OAuth2 token
    while (true) : (std.Thread.sleep(50000000)) {
        flow.state.mutex.lock();
        defer flow.state.mutex.unlock();
        if (flow.state.token != null) {
            break;
        }
    }
    // ya nadie mas va a acceder al lock, igual lo hago "prolijo"
    flow.state.mutex.lock();
    defer flow.state.mutex.unlock();
    //

    var playlist = try Playlist.build(
        arena.allocator(),

        playlist_name,
        flow.state.token.?.access_token,
        playlist_description,
    );
    try playlist.create();
    try playlist.populate(song_results.items, progress);
    try playlist.upload();

    std.debug.print("Done pushing playlist\n", .{});
}

fn search_track_threaded(global_state: *GlobalState, allocator: std.mem.Allocator, tokener: *SerializedToken, song: SongMetadata) void {
    const result = TrackSearch.make_request(
        allocator,
        tokener,
        song.song,
        song.album,
        song.artist,
        2,
        global_state.logs,
        &global_state.errlock,
    ) catch |err| {
        std.debug.print("Error en la busqueda del track {s} : {any}", .{ song.song, err });
        return;
    };
    global_state.lock.lock();
    defer {
        song.deinit();
        global_state.wg.finish();
        global_state.lock.unlock();
    }

    global_state.results.append(result) catch |err| {
        std.debug.print("Result gotten to but not finished :{any}\n", .{err});
        return;
    };
    global_state.progress.completeOne();
}

const GlobalState = struct { lock: std.Thread.Mutex, results: *std.ArrayList(TrackSearch), progress: std.Progress.Node, logs: *std.fs.File, errlock: std.Thread.Mutex, wg: *std.Thread.WaitGroup };
