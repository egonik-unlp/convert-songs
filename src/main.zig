const std = @import("std");
const http = std.http;
const SerializedToken = @import("spotify-token").SerializedToken;
const AlbumRequest = @import("album").AutoGenerated;
const TrackSearch = @import("track").TrackSearchResult;
const get_song_names = @import("file-extractor").get_song_names;
const SongMetadata = @import("file-extractor").SongMetadata;
const Playlist = @import("playlist").Playlist;
const TokenReponse = @import("playlist").TokenResponse;
const httpz = @import("httpz");
const Oauth2Flow = @import("server").Oauth2Flow;
const clap = @import("clap");
const ParseError = error{ ParseNameError, NoPathError };

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{ .stack_trace_frames = 10 }){};
    var arena = std.heap.ArenaAllocator.init(gpa.allocator());
    std.debug.print("Program running\n", .{});
    defer {
        arena.deinit();
        const status = gpa.deinit();
        std.debug.print("Status at end: {any}\n", .{status});
    }
    const params = comptime clap.parseParamsComptime(
        \\-h, --help             Display this help and exit.
        \\-d, --desc <str>       Playlist description.
        \\-n, --name <str>       Playlist name.
        \\-p, --path <str>       Folder path.
        \\
    );
    var diag = clap.Diagnostic{};
    var res = clap.parse(clap.Help, &params, clap.parsers.default, .{
        .diagnostic = &diag,
        .allocator = arena.allocator(),
    }) catch |err| {
        // Report useful error and exit.
        diag.report(std.io.getStdErr().writer(), err) catch {};
        return err;
    };
    defer res.deinit();
    if (res.args.help != 0)
        return clap.help(std.io.getStdErr().writer(), clap.Help, &params, .{});
    const path = pn: {
        if (res.args.path) |path| {
            break :pn path;
        } else {
            std.debug.print("No se proveyo ningun path para explorar.\n", .{});
            try clap.help(std.io.getStdErr().writer(), clap.Help, &params, .{});
            return ParseError.NoPathError;
        }
    };

    const playlist_name = pn: {
        if (res.args.name) |name| {
            break :pn name;
        } else {
            std.debug.print("No se proveyo ningun nombre para la playlist.\n", .{});
            try clap.help(std.io.getStdErr().writer(), clap.Help, &params, .{});
            return ParseError.ParseNameError;
        }
    };

    const playlist_description = pd: {
        if (res.args.desc) |desc| {
            break :pd desc;
        } else {
            break :pd "Creado con convert-songs";
        }
    };

    var tokener = try SerializedToken.init(arena.allocator());
    _ = try tokener.retrieve();
    var flow = try Oauth2Flow.build(8888, arena.allocator());
    var thread = try flow.run();
    defer thread.join();
    defer flow.server.stop();

    const progress = std.Progress.start(.{ .root_name = "Procesando tracks" });
    defer progress.end();
    const songs_in_dir = try get_song_names(path, gpa.allocator(), progress);
    if (songs_in_dir.items.len == 0) {
        std.debug.print("No tracks detected", .{});
        return;
    }
    std.debug.print("Canciones son {d}\n", .{songs_in_dir.items.len});
    var song_results = std.ArrayList(TrackSearch).init(arena.allocator());

    const search_subnode = progress.start("Searching Tracks", songs_in_dir.items.len);
    defer search_subnode.end();
    defer songs_in_dir.deinit();
    for (songs_in_dir.items) |song| {
        search_subnode.completeOne();
        const result = try TrackSearch.make_request(arena.allocator(), &tokener, song.song, song.album, song.artist, 2);
        try song_results.append(result);
        song.deinit();
    }

    //----------------------------------------------------------///
    flow.state.mutex.lock();
    std.debug.print("Waiting on login completion", .{});
    flow.state.wg.wait();
    flow.state.mutex.unlock();

    var playlist = try Playlist.build(
        arena.allocator(),

        playlist_name,
        flow.state.token.?.access_token,
        playlist_description,
    );
    try playlist.create();
    try playlist.populate(song_results.items, progress);
    try playlist.upload();

    std.debug.print("Done pushing playlist\n", .{});
}
