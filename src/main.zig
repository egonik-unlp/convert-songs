const std = @import("std");
const http = std.http;
const SerializedToken = @import("spotify-token").SerializedToken;
const AlbumRequest = @import("album").AutoGenerated;
const TrackSearch = @import("track").TrackSearchResult;
const get_song_names = @import("file-extractor").get_song_names;
const SongMetadata = @import("file-extractor").SongMetadata;
const Playlist = @import("playlist").Playlist;
const TokenReponse = @import("playlist").TokenResponse;
const httpz = @import("httpz");
const Oauth2Flow = @import("server").Oauth2Flow;

fn make_sample_request(token: []const u8, alloc: std.mem.Allocator, album_id: []const u8) !std.ArrayList(u8) {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    var local_arena = std.heap.ArenaAllocator.init(gpa.allocator());
    defer local_arena.deinit();
    const url = try std.fmt.allocPrint(local_arena.allocator(), "https://api.spotify.com/v1/albums/{s}", .{album_id});
    var client = http.Client{ .allocator = local_arena.allocator() };
    var buffer = std.ArrayList(u8).init(alloc);
    const bearer = try std.fmt.allocPrint(local_arena.allocator(), "Bearer {s}", .{token});
    const respcode = try client.fetch(http.Client.FetchOptions{
        .headers = .{ .authorization = .{ .override = bearer } },
        .location = .{ .uri = try std.Uri.parse(url) },
        .method = .GET,
        .response_storage = .{ .dynamic = &buffer },
    });
    std.debug.print("Request Status: {}\n", .{respcode.status});

    return buffer;
}

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    var arena = std.heap.ArenaAllocator.init(gpa.allocator());
    defer arena.deinit();
    var tokener = try SerializedToken.init(arena.allocator());
    _ = try tokener.retrieve();
    var flow = try Oauth2Flow.build(8888, arena.allocator());
    var thread = try flow.run();
    defer thread.join();
    defer flow.server.stop();
    const args = try std.process.argsAlloc(arena.allocator());
    const playlist_name, const playlist_description = switch (args.len) {
        1 => {
            std.debug.print("No se proveyeron nombre y descripcion para la playlist a crear\n", .{});
            return;
        },
        2 => inner: {
            std.debug.print("Solo se proveyo un argumento. Se asume que el nombre de la playlist es {s} y la descripcion se usara la default\n", .{args[1]});
            break :inner .{ args[1], "Created with convert-songs" };
        },
        3 => .{ args[1], args[2] },
        else => {
            std.debug.print("Demasiados argumentos\n", .{});
            return;
        },
    };
    const progress = std.Progress.start(.{ .root_name = "Procesando tracks" });
    defer progress.end();

    const songs_in_dir = try get_song_names("/home/gonik/Music/Nicotine/", arena.allocator(), progress);

    std.debug.print("Canciones son {d}\n", .{songs_in_dir.items.len});
    var song_results = std.ArrayList(TrackSearch).init(arena.allocator());
    var file = try std.fs.cwd().createFile("logs", .{});
    const search_subnode = progress.start("Searching Tracks", songs_in_dir.items.len);
    defer search_subnode.end();
    for (songs_in_dir.items) |song| {
        search_subnode.completeOne();
        const result = try TrackSearch.make_request(
            arena.allocator(),
            &tokener,
            song.song,
            song.album,
            song.artist,
            2,
            &file,
        );
        try song_results.append(result);
        errdefer std.debug.print("Failing query {s} {s} {s}\n", .{ song.song, song.album, song.artist });
    }
    std.debug.print("Se procesaron todas las canciones del directorio seleccionado\n", .{});

    // Wait for 0.5s for OAuth2 token
    while (true) : (std.Thread.sleep(50000000)) {
        flow.state.mutex.lock();
        defer flow.state.mutex.unlock();
        if (flow.state.token != null) {
            break;
        }
    }
    // ya nadie mas va a acceder al lock, igual lo hago "prolijo"
    flow.state.mutex.lock();
    defer flow.state.mutex.unlock();
    //

    var playlist = try Playlist.build(
        arena.allocator(),

        playlist_name,
        flow.state.token.?.access_token,
        playlist_description,
    );
    try playlist.create();
    try playlist.populate(song_results.items, progress);
    try playlist.upload();

    std.debug.print("Done pushing playlist\n", .{});
}
