const std = @import("std");
const http = std.http;
const SerializedToken = @import("spotify-token").SerializedToken;
const AlbumRequest = @import("album").AutoGenerated;
const TrackSearch = @import("track").TrackSearchResult;
const get_song_names = @import("file-extractor").get_song_names;
const SongMetadata = @import("file-extractor").SongMetadata;
const Playlist = @import("playlist").Playlist;
const TokenReponse = @import("playlist").TokenResponse;
const httpz = @import("httpz");
const Oauth2Flow = @import("server").Oauth2Flow;
const clap = @import("clap");
const ParseError = error{ ParseNameError, NoPathError };

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    var arena = std.heap.ArenaAllocator.init(gpa.allocator());
    defer arena.deinit();

    const params = comptime clap.parseParamsComptime(
        \\-h, --help             Display this help and exit.
        \\-d, --desc <str>       Playlist description.
        \\-n, --name <str>       Playlist name.
        \\-p, --path <str>       Folder path.
        \\
    );
    var diag = clap.Diagnostic{};
    var res = clap.parse(clap.Help, &params, clap.parsers.default, .{
        .diagnostic = &diag,
        .allocator = arena.allocator(),
    }) catch |err| {
        // Report useful error and exit.
        diag.report(std.io.getStdErr().writer(), err) catch {};
        return err;
    };
    defer res.deinit();
    if (res.args.help != 0)
        return clap.help(std.io.getStdErr().writer(), clap.Help, &params, .{});
    const path = pn: {
        if (res.args.path) |path| {
            break :pn path;
        } else {
            std.debug.print("No se proveyo ningun path para explorar.\n", .{});
            try clap.help(std.io.getStdErr().writer(), clap.Help, &params, .{});
            return ParseError.NoPathError;
        }
    };

    const playlist_name = pn: {
        if (res.args.name) |name| {
            break :pn name;
        } else {
            std.debug.print("No se proveyo ningun nombre para la playlist.\n", .{});
            try clap.help(std.io.getStdErr().writer(), clap.Help, &params, .{});
            return ParseError.ParseNameError;
        }
    };

    const playlist_description = pd: {
        if (res.args.desc) |desc| {
            break :pd desc;
        } else {
            break :pd "Creado con convert-songs";
        }
    };

    var tokener = try SerializedToken.init(arena.allocator());
    _ = try tokener.retrieve();
    var flow = try Oauth2Flow.build(8888, arena.allocator());
    var thread = try flow.run();
    defer thread.join();
    defer flow.server.stop();

    const progress = std.Progress.start(.{ .root_name = "Procesando tracks" });
    defer progress.end();

    const songs_in_dir = try get_song_names(path, gpa.allocator(), progress);
    if (songs_in_dir.items.len == 0) {
        std.debug.print("No tracks detected", .{});
        return;
    }
    std.debug.print("Canciones son {d}\n", .{songs_in_dir.items.len});
    var song_results = std.ArrayList(TrackSearch).init(arena.allocator());

    var file = try std.fs.cwd().createFile("logs", .{});
    const search_subnode = progress.start("Searching Tracks", songs_in_dir.items.len);
    defer search_subnode.end();
    defer songs_in_dir.deinit();
    var pool: std.Thread.Pool = undefined;
    try pool.init(.{ .allocator = arena.allocator(), .n_jobs = 8 });
    for (songs_in_dir.items) |song| {
        search_subnode.completeOne();
        const result = try TrackSearch.make_request(
            arena.allocator(),
            &tokener,
            song.song,
            song.album,
            song.artist,
            2,
            &file,
        );

        try song_results.append(result);
    }

    defer pool.deinit();
    std.debug.print("Se procesaron todas las canciones del directorio seleccionado\n", .{});

    // Wait for 0.5s for OAuth2 token
    while (true) : (std.Thread.sleep(50000000)) {
        flow.state.mutex.lock();
        defer flow.state.mutex.unlock();
        if (flow.state.token != null) {
            break;
        }
    }
    // ya nadie mas va a acceder al lock, igual lo hago "prolijo"
    flow.state.mutex.lock();
    defer flow.state.mutex.unlock();
    //

    var playlist = try Playlist.build(
        arena.allocator(),

        playlist_name,
        flow.state.token.?.access_token,
        playlist_description,
    );
    try playlist.create();
    try playlist.populate(song_results.items, progress);
    try playlist.upload();

    std.debug.print("Done pushing playlist\n", .{});
}
fn search_track(
    progress: std.Progress.Node,
    results: *std.ArrayListAligned(TrackSearch, null),
    song: SongMetadata,
    file: *std.fs.File,
    allocator: std.mem.Allocator,
    tokener: *SerializedToken,
) !void {
    progress.completeOne();
    const result = try TrackSearch.make_request(
        allocator,
        tokener,
        song.song,
        song.album,
        song.artist,
        2,
        file,
    );

    results.append(result);
}
