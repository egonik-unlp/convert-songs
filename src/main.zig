const std = @import("std");
const http = std.http;
const fmt = std.fmt;
const dotenv = @import("dotenv");
const album_code = "06zWjeOA3MwBHLApKUS3Qs?si=LkxC6rN9QhmXiY67dQ6QYQ";
const SpotifyResponse = struct {
    access_token: []u8,
    token_type: []u8,
    expires_in: i32,
};

const InnerToken = struct { token: []const u8, expiration_timestamp: i64 };

const SerializedToken = struct {
    expiration_timestamp: i64,
    token: []u8,
    arena: std.mem.Allocator,
    fn init(allocator: std.mem.Allocator) !SerializedToken {
        const filename = "dump.a";
        const cwd = std.fs.cwd();
        const file = cwd.openFile(filename, .{});
        const token, const expiration_timestamp = if (file) |value| {
            const str = try value.readToEndAlloc(allocator, 4096);
            const token_data = try std.json.parseFromSlice(InnerToken, allocator, str, .{ .ignore_unknown_fields = true });
            &.{ token_data.value.token, token_data.value.expiration_timestamp };
        } else |err| {
            switch (err) {
                std.fs.File.OpenError.FileNotFound => get_token(allocator),
                else => err,
            }
        };
        const ret = SerializedToken{ .expiration_timestamp = expiration_timestamp, .token = token, .arena = allocator };
        return ret;
    }
    fn retrieve(self: SerializedToken) []u8 {
        return self.token;
    }
};

test "gets token" {
    const testing = std.testing.allocator;
    var local_arena = std.heap.ArenaAllocator.init(testing);
    defer local_arena.deinit();
    const token_wrapper = try SerializedToken.init(local_arena.allocator());
    const token1 = token_wrapper.retrieve();
    const token_wrapper2 = try SerializedToken.init(local_arena.allocator());
    const token2 = token_wrapper2.retrieve();
    std.testing.expectEqual(token1, token2);
}
const AlbumRequest = @import("deserialize").AutoGenerated;

fn get_token(allo: std.mem.Allocator) ![2][]u8 {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    var local_arena = std.heap.ArenaAllocator.init(gpa.allocator());
    defer local_arena.deinit();
    const client_id, const client_secret = try get_dotenv(local_arena.allocator());
    var client = http.Client{ .allocator = local_arena.allocator() };
    const url = try std.Uri.parse("https://accounts.spotify.com/api/token");
    var buf: [4096]u8 = undefined;
    const headers = http.Client.Request.Headers{ .content_type = .{ .override = "application/x-www-form-urlencoded" } };
    const body = try fmt.allocPrint(local_arena.allocator(), "grant_type=client_credentials&client_id={s}&client_secret={s}", .{ client_id, client_secret });
    var response = std.ArrayList(u8).init(local_arena.allocator());
    const options = http.Client.FetchOptions{ .response_storage = .{ .dynamic = &response }, .method = .POST, .payload = body, .server_header_buffer = &buf, .headers = headers, .location = http.Client.FetchOptions.Location{ .uri = url } };
    _ = try client.fetch(options);
    const obj = try std.json.parseFromSlice(SpotifyResponse, allo, response.items, .{});
    const token = obj.value.access_token;
    const expiration = obj.value.expires_in;
    std.debug.print("Token expires in = {}", .{obj.value.expires_in});
    return .{ token, expiration };
}
fn get_dotenv(allocator: std.mem.Allocator) ![2][]const u8 {
    var envs = try dotenv.getDataFrom(allocator, ".env");
    const client_id = envs.get("client_id").?.?;
    const client_secret = envs.get("client_secret").?.?;
    return .{ client_id, client_secret };
}
fn make_sample_request(token: []u8, alloc: std.mem.Allocator, album_id: []const u8) !std.ArrayList(u8) {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    var local_arena = std.heap.ArenaAllocator.init(gpa.allocator());
    defer local_arena.deinit();
    const url = try fmt.allocPrint(local_arena.allocator(), "https://api.spotify.com/v1/albums/{s}", .{album_id});
    var client = http.Client{ .allocator = local_arena.allocator() };
    var buffer = std.ArrayList(u8).init(alloc);
    const bearer = try fmt.allocPrint(local_arena.allocator(), "Bearer {s}", .{token});
    const respcode = try client.fetch(http.Client.FetchOptions{
        .headers = .{ .authorization = .{ .override = bearer } },
        .location = .{ .uri = try std.Uri.parse(url) },
        .method = .GET,
        .response_storage = .{ .dynamic = &buffer },
    });
    std.debug.print("Request Status: {}\n", .{respcode.status});
    return buffer;
}

// pub fn retrieveToken() !void {
//     std.time.
// }
pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    var arena = std.heap.ArenaAllocator.init(gpa.allocator());
    defer arena.deinit();
    const args = try std.process.argsAlloc(arena.allocator());
    const path = if (args.len >= 2) args[1] else unreachable;
    const token = try get_token(arena.allocator());
    const api_response = try make_sample_request(
        token,
        arena.allocator(),
        path,
    );
    const resp = api_response.items;
    try write_to_json(resp);
    const laika = try deserialize(resp, arena.allocator());
    std.debug.print("Artista = {s}\n", .{laika.artists[0].name});
    // std.debug.print("token = {s}", .{token});
    // std.debug.print("Info album = {s}", .{resp});
}

fn write_to_json(response: []const u8) !void {
    const cwd = std.fs.cwd();
    const file = try cwd.createFile("album.json", .{});
    try file.writeAll(response);
}
fn deserialize(response: []const u8, alloc: std.mem.Allocator) !AlbumRequest {
    const parsed = try std.json.parseFromSlice(AlbumRequest, alloc, response, .{ .ignore_unknown_fields = true });
    return parsed.value;
}
